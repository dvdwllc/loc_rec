import pandas as pd
import numpy as np
from sqlalchemy import create_engine
from scripts import mapcalc, get_user_POIs
import geocoder

# Initializes database with filename baltimore.db in current directory
disk_engine = create_engine('sqlite:///baltimore.db')


class recommender(object):
    """
    Recommends a location based on a list of queries.
    The queries will be generated by either an empty field
    (for manual address entry) or by a dropdown menu for specific
    datasets.
    """

    def __init__(self, queries):
        self.queries = queries
        self.n_queries = len(self.queries)
        self.maps = []

    def compute_maps(self):
        for i in range(self.n_queries):
            q = self.queries[i]

            # If query is to a database with unique identifier columns
            if type(q) == tuple:

                formatted_query = (
                    'SELECT Latitude, Longitude '
                    'FROM "{}" WHERE "{}" = "{}";'
                        .format(q[0], q[1], q[2])
                )

                result = pd.read_sql_query(formatted_query, disk_engine)

                if q[0] == 'arrests':
                    # Compute heatmap (2D histogram)
                    self.maps.append( \
                        mapcalc.hist2d_bmoredata(result, 0, 0) + 1.0)

                else:
                    # Compute heatmap (2D grid of distance to nearest POI)
                    self.maps.append(mapcalc.compute_distances_to_POIs(result))

            else:
                # If query is database with no unique identifiers
                if q == 'vacancies' or q == 'restaurants' or q == 'top50':

                    formatted_query = (
                        'SELECT Latitude, Longitude FROM "{}";'.format(q)
                    )

                    result = pd.read_sql_query(formatted_query, disk_engine)
                    if q == 'vacancies':
                        # Compute heatmap (2D histogram)
                        self.maps.append(mapcalc.hist2d_bmoredata(result, 0, 0) + 1.0)
                    else:
                        # Compute heatmap (2D grid of distance to nearest POI)
                        self.maps.append(mapcalc.compute_distances_to_POIs(result))

                # If query is a user-input address
                else:
                    result = get_user_POIs.add_user_POI(q)
                    try:
                        # Compute heatmap (2D grid of distance to nearest POI)
                        self.maps.append \
                            (mapcalc.compute_distances_to_POIs(result))

                    except TypeError:
                        print 'Failed to geocode manually entered location.'

    def recommend_location(self):
        # compute heatmap
        map_array = np.array(self.maps)
        heatmap = np.prod((map_array), axis=0)
        lowest_val = np.amin(heatmap)

        # find hottest spot
        opt_lat, opt_lon = np.argwhere(heatmap == lowest_val)[0]

        # determine address from lat/lon of hottest spot
        address = geocoder.google('%.10f, %.10f' % (
            mapcalc.y[opt_lat], mapcalc.x[opt_lon]
        )).address

        return address

    def recommendation_map(self):
        map_array = np.array(self.maps)
        heatmap = np.prod((map_array), axis=0)
        x, y, heatmap = mapcalc.produce_map_for_app(1.0 / heatmap)

        return x, y, heatmap


if __name__ == '__main__':
    #for testing purposes
    JHU = ('3400 N Charles St, Baltimore, MD')
    Fells = ('Fells Point, Baltimore, MD')
    q1 = 'groceries', 'type', 'Full Supermarket'
    q2 = 'arrests', 'Offense', '87-Narcotics'
    q3 = 'vacancies'
    my_spot = recommender([Fells, q1, q2, q3])
    my_spot.compute_maps()
    loc_map = my_spot.recommend_location_map()
    print 'You should search for a property near %s' % loc_map
